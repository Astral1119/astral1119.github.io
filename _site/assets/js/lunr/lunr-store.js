var store = [{
        "title": "The Crash Bug",
        "excerpt":"Introduction   Since this is my first post here, I figured I’d start strong.   Not too long ago, I was designing an intermediate to advanced formula practice sheet when I accidentally hit enter on one of the formulae intended to generate test data. (I’ll probably make some posts on the formula practice sheet later.) It immediately crashed the sheet, and would continuously spit out the following:      So clearly, something went pretty horribly wrong. It completely bricked the workbook, but for some reason it still let me access it through iOS sheets so I was able to salvage it.   So what happened?   The Bug   Well, the first part of the problem I needed to solve was reducing the formula that created the problem. Here’s what it looked like when it crashed the sheet:   =index(lambda(d,lambda(e,reduce(\"!\",d,lambda(a,c,lambda(f,if(and(a=\"!\"),f,{a,f}))(flatten(filter(query(d,\"where Col1 is not null offset 1\",),index(d,1,)=c))))))(reduce(\"!\",sequence(12)+1,lambda(a,c,lambda(y,if(and(a=\"!\"),y,{a,y}))({text(date(,c,),\"mmmm\"),d;query(map(sequence(20),lambda(x,lambda(y,z,{\"Item \"&amp;randbetween(1,30),y,y*z,z})(randbetween(1,10),randbetween(5,10)))),\"select 2/0,Col1,Col2,Col3,Col4,1/0label 1/0'',2/0''\",)}))))({\"SKU\",\"Quantity\",\"Total Price\",\"Average Price\",\"\"})))   This is obviously not the most readable. It was also designed before LET and HSTACK came to Google Sheets, so everything is obscured behind nested LAMBDAs. But slowly, I started chipping away at it, and eventually I was left with the following:   =index(lambda(,))   That’s it. That’s all you need to nuke a sheet.   The Investigation   I did a little more testing, and found that this only happened when LAMBDA had a variable expressed, and no argument passed to it; the variable name didn’t even need to be valid, but my guess is something about LAMBDA execution outputs an error that carries down if no arguments are expressed. For example,   =index(lambda())   outputs an error, but doesn’t cause a meltdown. Instead, it sends out a #N/A error due to having too few arguments. Hence, a comma is necessary for the bug to occur.   The next thing I tried was wrapping it in IFERROR or literally any other function, and it persisted. Something about the interaction between INDEX and an argumentless LAMBDA causes a fatal error. Interestingly,   =if(,index(lambda(,)))   does not cause an error. If is quite nice because it only evaluates the condition corresponding to the Boolean it is passed. What this effectively means is that the =index(lambda(,)) needs to be parsed and evaluated to have an effect. Which makes sense.   Further along in my testing, I was able to induce a state where I was able to edit a bugged sheet without being kicked out. I still have no idea how it happened or how to replicate it, but it was extremely handy to be able to have one tab where I was not continuously kicked out and another to see if whatever I was testing had any effects.   Elly Helps Out   It was at this point I shared what information I had with some of the lovely folks over on the Spreadsheets Discord Community. One person in particular, Elly, was instrumental in determining the cause of this issue. After playing around with it for a while, they sent me this:      I couldn’t believe I hadn’t thought to look at the console! Lo and behold, we have the exact cause of the fatal error. It seems like searchArrayOrRef, a backend function used in INDEX, is not compatible with new data types that result from LAMBDA.   Extending the Bug   But to go one step further, I was a bit intrigued by the searchArrayOrRef function. Given its name, I guessed that it would be used in functions of the Lookup type. As it turns out, LOOKUP, MATCH, XLOOKUP, etc. are all susceptible to this error.   Of course, with proper syntax, this is a non-issue. With how new LAMBDA is, and how game-changing it’s proven to be already, I think issues were to be expected. I’m not sure if there are any meaningful implications to this adventure, other than that finding a bug in one of a trillion-dollar company’s flagship products is pretty nifty. But if you’re curious, you can find out more at this link.   ‘Til later,   - Astral  ","categories": [],
        "tags": ["bugs"],
        "url": "/crash-bug/",
        "teaser": "/assets/images/broken.jpg"
      },{
        "title": "Levenshtein Distance Formula",
        "excerpt":"Introduction   This problem arose when ztiaa challenged me to create a formula that calculates the Levenshtein distance between two strings. In simple terms, the Levenshtein distance is how many edits it would take to get from one string to another. It has a number of very nice applications in fuzzy matching, a topic on which I’ll likely make additional posts on in the future.   With Levenshtein, there are three accepted actions: removal, insertion, and substitution. Each can be weighted but most implementations use weights of 1.   For example, the Levenshtein distance between the words “chat” and “act” is three.      Step 1: Substitute c with a - ahat   Step 2: Remove h - aat   Step 3: Substitute a with c - act   You can also get there through removals and insertions.      Step 1: Remove c - hat   Step 2: Remove h - at   Step 3: Insert c - act   Pretty simple, right? But the issue arises with the algorithm.   The Algorithm   Here’s the mathematical definition Wikipedia provides:      Now, I’m a high schooler who was never formally taught any of this stuff. It also doesn’t help that very little of it is analogous to Google Sheets formulae. But I came across a very nice Medium article by Ethan Nam that helped illustrate the concept. I highly recommend giving it a read.   Anyways, I opted for a matrix implementation. However, we only really need to account for the last matrix row we calculated. Let’s call it previous. We also need to keep track of a source and target string, as well as the current index in the source string. As per the algorithm, we start by initializing previous. That sounds kind of fancy, but really it just means assigning a number to each letter in target and tacking a 0 to the beginning of that. So, if our target is “act”, the initialized previous row looks like this:                          a       c       t                       0       1       2       3           Awesome. Now, we need to iterate it. An iteration can be described in a couple steps:      Take the value to the left and add one to it.   Take the value directly above and add one to it.   Check if the characters in the target and source strings corresponding to this spot match.   Take the value one up and one left. If they match, add nothing. If they don’t, add one to it.   Take the minimum value of the three values you just calculated. That’s the value for this spot.   For example, take the first iteration. For convenience, I’ve also gone ahead and added numbers to refer to each spot with in the first row and column. I’ll refer to each spot as (row,column).                                  1       2       3       4                                               a       c       t                                 0       1       2       3                 1       c                                                 2       h                                                 3       a                                                 4       t                                           We start by taking our three values for (1,1). There’s only one valid value, 0, and we add one to it to get 1.                                  1       2       3       4                                               a       c       t                                 0       1       2       3                 1       c       1                                         2       h                                                 3       a                                                 4       t                                           Now, we look at (1,2). If you recall the five steps I outlined above:      The value to the left is 1. Add one to it to get 2.   The value directly above is 1. Add one to it to get 2.   The character in row 1, “c”, does not match the character in column 2, “a”.   The value up and to the left is 0. Since the characters don’t match, add one to it to get 1.   The minimum of 2, 2, and 1 is 1, so our new value is 1.                                  1       2       3       4                                               a       c       t                                 0       1       2       3                 1       c       1       1                                 2       h                                                 3       a                                                 4       t                                              The value to the left is 1. Add one to it to get 2.   The value directly above is 2. Add one to it to get 3.   The character in row 1, “c”, matches the character in column 3, “c”.   So we take the value up and to the left, 1.   The minimum of 2, 3, and 1 is 1, so our new value is 1.   This process continues on for each letter in source.                                  1       2       3       4                                               a       c       t                                 0       1       2       3                 1       c       1       1       1       2                 2       h       2       2       2       2                 3       a       3       2       3       3                 4       t       4       3       3       3           Finally, once we’ve gone all the way through, all we need to do is take the value in the bottom right corner. And that’s it! We’ve just calculated the Levenshtein distance between the two strings!   I also realized that you don’t actually have to store all of the rows between iterations. Rather, you just need to hold onto the last row you calculated.   The Formula   This is the formula I developed. For readability, I’ve beautified it and redefined the variables.   =let(     source,     \"chat\",     target,     \"act\",     index(         reduce(             { 0 ,                 sequence(                     1,                     len(                         target                     )                 ) },             sequence(                 len(                     source                 )             ),             lambda(                 previous,                 current,                 scan(                     #N/A,                     sequence(                         1,                         len(                             target                         ) + 1                     ),                     lambda(                         left,                         n,                         min(                             index(                                 previous,                                 n                             ) + 1,                             ifna(                                 left + 1                             ),                             iferror(                                 index(                                     previous,                                     n - 1                                 ) +                                 not(                                     exact(                                         mid(                                             source,                                             current,                                             1                                         ),                                         mid(                                             target,                                             n - 1,                                             1                                         )                                     )                                 )                             )                         )                     )                 )             )         ),         len(             target         ) + 1     ) )  It looks a bit intimidating when it’s all spaced out like this, in my opinion, so here it is compressed.   =let(source,\"chat\",target,\"act\",index(reduce({0,sequence(1,len(target))},sequence(len(source)),lambda(previous,current,scan(#N/A,sequence(1,len(target)+1),lambda(left,n,min(index(previous,n)+1,ifna(left+1),iferror(index(previous,n-1)+not(exact(mid(source,current,1),mid(target,n-1,1))))))))),len(target)+1))   Explanation   This formula just executes the five steps outlined above, using SCAN and REDUCE to iterate through it. Now that we’ve got the concepts out of the way, it’s time to get our hands dirty.   Firstly, the LET. LET allows us to define some variables that recur throughout. In this case, we’re setting our source to “chat” and our target to “act”. It also helps us generalize, and just makes everything easier to understand.   Next, the INDEX. Remember how the bottom right corner gave us our final answer? INDEX grabs that for us.   REDUCE is one of the most useful functions in Google Sheets. It takes the form REDUCE(initial_value, array_or_range, LAMBDA). So for the initial value, we give it our initialized previous array we talked about before. In Google Sheets formulae, that looks something like {0,sequence(1,len(target))}. Next, to iterate through each letter in the source string, we just need to give it a sequence equal in size to the length of the source string. This translates quite nicely, to sequence(len(source)). This also provides our current variable. Finally, the LAMBDA just lets us tell it what to do.   SCAN takes the same exact form as REDUCE. For its initial_value, we give it an error since there’s nothing left to the first column. For its array_or_range, we give it a sequence the length of our target, or sequence(1,len(target)). The LAMBDA tells it how to go through the five steps.      Take the value to the left and add one to it. We do this with left+1. The IFNA gets rid of the error we gave it.   Take the value directly above and add one to it. The row above is just our previous variable, so we can do this with index(previous,n)+1.   Check if the characters in the target and source strings corresponding to this spot match. This can be done with exact(mid(source,current,1),mid(target,n-1,1)).   Take the value one up and one left. If they match, add nothing. If they don’t, add one to it. We take the value up and to the left with index(previous,-1) and just add it to the inverse of the Boolean above. Altogether, it looks like iferror(index(previous,n-1)+not(exact(mid(source,current,1),mid(target,n-1,1)))).   Take the minimum value of the three values you just calculated. That’s the value for this spot. Wrap all three values we calculated in MIN and we’ve got the current value!   You can find see it in action here. I’ve also added ztiaa’s solution. Make sure to check out their blog!   Fare thee well,   - Astral   ","categories": [],
        "tags": ["formula"],
        "url": "/levenshtein-distance/",
        "teaser": "/assets/images/distance.jpg"
      },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/"
  },{
    "title": null,
    "excerpt":"var idx = lunr(function () {   this.field('title')   this.field('excerpt')   this.field('categories')   this.field('tags')   this.ref('id')    this.pipeline.remove(lunr.trimmer)    for (var item in store) {     this.add({       title: store[item].title,       excerpt: store[item].excerpt,       categories: store[item].categories,       tags: store[item].tags,       id: item     })   } });  $(document).ready(function() {   $('input#search').on('keyup', function () {     var resultdiv = $('#results');     var query = $(this).val().toLowerCase();     var result =       idx.query(function (q) {         query.split(lunr.tokenizer.separator).forEach(function (term) {           q.term(term, { boost: 100 })           if(query.lastIndexOf(\" \") != query.length-1){             q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })           }           if (term != \"\"){             q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })           }         })       });     resultdiv.empty();     resultdiv.prepend(''+result.length+' Result(s) found ');     for (var item in result) {       var ref = result[item].ref;       if(store[ref].teaser){         var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+                 ''+               ''+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       else{     \t  var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       resultdiv.append(searchitem);     }   }); }); ","url": "http://localhost:4000/assets/js/lunr/lunr-en.js"
  },{
    "title": null,
    "excerpt":"step1list = new Array(); step1list[\"ΦΑΓΙΑ\"] = \"ΦΑ\"; step1list[\"ΦΑΓΙΟΥ\"] = \"ΦΑ\"; step1list[\"ΦΑΓΙΩΝ\"] = \"ΦΑ\"; step1list[\"ΣΚΑΓΙΑ\"] = \"ΣΚΑ\"; step1list[\"ΣΚΑΓΙΟΥ\"] = \"ΣΚΑ\"; step1list[\"ΣΚΑΓΙΩΝ\"] = \"ΣΚΑ\"; step1list[\"ΟΛΟΓΙΟΥ\"] = \"ΟΛΟ\"; step1list[\"ΟΛΟΓΙΑ\"] = \"ΟΛΟ\"; step1list[\"ΟΛΟΓΙΩΝ\"] = \"ΟΛΟ\"; step1list[\"ΣΟΓΙΟΥ\"] = \"ΣΟ\"; step1list[\"ΣΟΓΙΑ\"] = \"ΣΟ\"; step1list[\"ΣΟΓΙΩΝ\"] = \"ΣΟ\"; step1list[\"ΤΑΤΟΓΙΑ\"] = \"ΤΑΤΟ\"; step1list[\"ΤΑΤΟΓΙΟΥ\"] = \"ΤΑΤΟ\"; step1list[\"ΤΑΤΟΓΙΩΝ\"] = \"ΤΑΤΟ\"; step1list[\"ΚΡΕΑΣ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΟΣ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΑ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΩΝ\"] = \"ΚΡΕ\"; step1list[\"ΠΕΡΑΣ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΟΣ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΑ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΩΝ\"] = \"ΠΕΡ\"; step1list[\"ΤΕΡΑΣ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΟΣ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΑ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΩΝ\"] = \"ΤΕΡ\"; step1list[\"ΦΩΣ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΟΣ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΑ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΩΝ\"] = \"ΦΩ\"; step1list[\"ΚΑΘΕΣΤΩΣ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΟΣ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΑ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΩΝ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΓΕΓΟΝΟΣ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΟΣ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΑ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΩΝ\"] = \"ΓΕΓΟΝ\";  v = \"[ΑΕΗΙΟΥΩ]\"; v2 = \"[ΑΕΗΙΟΩ]\"  function stemWord(w) {   var stem;   var suffix;   var firstch;   var origword = w;   test1 = new Boolean(true);    if(w.length '+result.length+' Result(s) found ');     for (var item in result) {       var ref = result[item].ref;       if(store[ref].teaser){         var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+                 ''+               ''+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       else{     \t  var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       resultdiv.append(searchitem);     }   }); }); ","url": "http://localhost:4000/assets/js/lunr/lunr-gr.js"
  },{
    "title": null,
    "excerpt":"var store = [   {%- for c in site.collections -%}     {%- if forloop.last -%}       {%- assign l = true -%}     {%- endif -%}     {%- assign docs = c.docs | where_exp:'doc','doc.search != false' -%}     {%- for doc in docs -%}       {%- if doc.header.teaser -%}         {%- capture teaser -%}{{ doc.header.teaser }}{%- endcapture -%}       {%- else -%}         {%- assign teaser = site.teaser -%}       {%- endif -%}       {         \"title\": {{ doc.title | jsonify }},         \"excerpt\":           {%- if site.search_full_content == true -%}             {{ doc.content | newline_to_br |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \"|             strip_html | strip_newlines | jsonify }},           {%- else -%}             {{ doc.content | newline_to_br |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \"|             strip_html | strip_newlines | truncatewords: 50 | jsonify }},           {%- endif -%}         \"categories\": {{ doc.categories | jsonify }},         \"tags\": {{ doc.tags | jsonify }},         \"url\": {{ doc.url | relative_url | jsonify }},         \"teaser\": {{ teaser | relative_url | jsonify }}       }{%- unless forloop.last and l -%},{%- endunless -%}     {%- endfor -%}   {%- endfor -%}{%- if site.lunr.search_within_pages -%},   {%- assign pages = site.pages | where_exp:'doc','doc.search != false' -%}   {%- for doc in pages -%}     {%- if forloop.last -%}       {%- assign l = true -%}     {%- endif -%}   {     \"title\": {{ doc.title | jsonify }},     \"excerpt\":         {%- if site.search_full_content == true -%}           {{ doc.content | newline_to_br |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \"|           strip_html | strip_newlines | jsonify }},         {%- else -%}           {{ doc.content | newline_to_br |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \"|           strip_html | strip_newlines | truncatewords: 50 | jsonify }},         {%- endif -%}       \"url\": {{ doc.url | absolute_url | jsonify }}   }{%- unless forloop.last and l -%},{%- endunless -%}   {%- endfor -%} {%- endif -%}] ","url": "http://localhost:4000/assets/js/lunr/lunr-store.js"
  },{
    "title": null,
    "excerpt":" {% if page.xsl %} {% endif %} {% assign collections = site.collections | where_exp:'collection','collection.output != false' %}{% for collection in collections %}{% assign docs = collection.docs | where_exp:'doc','doc.sitemap != false' %}{% for doc in docs %} {{ doc.url | replace:'/index.html','/' | absolute_url | xml_escape }} {% if doc.last_modified_at or doc.date %}{{ doc.last_modified_at | default: doc.date | date_to_xmlschema }} {% endif %} {% endfor %}{% endfor %}{% assign pages = site.html_pages | where_exp:'doc','doc.sitemap != false' | where_exp:'doc','doc.url != \"/404.html\"' %}{% for page in pages %} {{ page.url | replace:'/index.html','/' | absolute_url | xml_escape }} {% if page.last_modified_at %}{{ page.last_modified_at | date_to_xmlschema }} {% endif %} {% endfor %}{% assign static_files = page.static_files | where_exp:'page','page.sitemap != false' | where_exp:'page','page.name != \"404.html\"' %}{% for file in static_files %} {{ file.path | replace:'/index.html','/' | absolute_url | xml_escape }} {{ file.modified_time | date_to_xmlschema }}  {% endfor %} ","url": "http://localhost:4000/sitemap.xml"
  },{
    "title": null,
    "excerpt":"Sitemap: {{ \"sitemap.xml\" | absolute_url }} ","url": "http://localhost:4000/robots.txt"
  },{
    "title": null,
    "excerpt":"{% if page.xsl %}{% endif %}Jekyll{{ site.time | date_to_xmlschema }}{{ page.url | absolute_url | xml_escape }}{% assign title = site.title | default: site.name %}{% if page.collection != \"posts\" %}{% assign collection = page.collection | capitalize %}{% assign title = title | append: \" | \" | append: collection %}{% endif %}{% if page.category %}{% assign category = page.category | capitalize %}{% assign title = title | append: \" | \" | append: category %}{% endif %}{% if title %}{{ title | smartify | xml_escape }}{% endif %}{% if site.description %}{{ site.description | xml_escape }}{% endif %}{% if site.author %}{{ site.author.name | default: site.author | xml_escape }}{% if site.author.email %}{{ site.author.email | xml_escape }}{% endif %}{% if site.author.uri %}{{ site.author.uri | xml_escape }}{% endif %}{% endif %}{% if page.tags %}{% assign posts = site.tags[page.tags] %}{% else %}{% assign posts = site[page.collection] %}{% endif %}{% if page.category %}{% assign posts = posts | where: \"category\", page.category %}{% endif %}{% unless site.show_drafts %}{% assign posts = posts | where_exp: \"post\", \"post.draft != true\" %}{% endunless %}{% assign posts = posts | sort: \"date\" | reverse %}{% assign posts_limit = site.feed.posts_limit | default: 10 %}{% for post in posts limit: posts_limit %}{% assign post_title = post.title | smartify | strip_html | normalize_whitespace | xml_escape %}{{ post_title }}{{ post.date | date_to_xmlschema }}{{ post.last_modified_at | default: post.date | date_to_xmlschema }}{{ post.id | absolute_url | xml_escape }}{% assign excerpt_only = post.feed.excerpt_only | default: site.feed.excerpt_only %}{% unless excerpt_only %}{{ post.content | strip | xml_escape }}{% endunless %}{% assign post_author = post.author | default: post.authors[0] | default: site.author %}{% assign post_author = site.data.authors[post_author] | default: post_author %}{% assign post_author_email = post_author.email | default: nil %}{% assign post_author_uri = post_author.uri | default: nil %}{% assign post_author_name = post_author.name | default: post_author %}{{ post_author_name | default: \"\" | xml_escape }}{% if post_author_email %}{{ post_author_email | xml_escape }}{% endif %}{% if post_author_uri %}{{ post_author_uri | xml_escape }}{% endif %}{% if post.category %}{% elsif post.categories %}{% for category in post.categories %}{% endfor %}{% endif %}{% for tag in post.tags %}{% endfor %}{% if post.excerpt and post.excerpt != empty %}{{ post.excerpt | strip_html | normalize_whitespace | xml_escape }}{% endif %}{% assign post_image = post.image.path | default: post.image %}{% if post_image %}{% unless post_image contains \"://\" %}{% assign post_image = post_image | absolute_url %}{% endunless %}{% endif %}{% endfor %}","url": "http://localhost:4000/feed.xml"
  }]
